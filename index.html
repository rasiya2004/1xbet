<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1xBet Crash Game Predictor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a2a6c, #2a3a7c, #3a4a8c);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #00ff88, #00ccff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header p {
            opacity: 0.8;
            font-size: 1.1em;
        }

        .warning {
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid rgba(255, 68, 68, 0.5);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel-title {
            font-size: 1.3em;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
            color: #00ff88;
        }

        /* Connection Status */
        .connection-status {
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .status-connected {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
        }

        .status-disconnected {
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid #ff4444;
        }

        .status-connecting {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid #ffcc00;
        }

        /* Prediction Display */
        .prediction-main {
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .prediction-value {
            font-size: 3em;
            font-weight: bold;
            margin: 10px 0;
            background: linear-gradient(45deg, #00ff88, #00ccff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .confidence-meter {
            margin: 20px 0;
        }

        .confidence-label {
            text-align: center;
            margin-bottom: 5px;
            font-size: 1.1em;
        }

        .confidence-bar {
            width: 100%;
            height: 25px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .confidence-fill {
            height: 100%;
            transition: width 0.5s ease;
        }

        .high-confidence { background: linear-gradient(90deg, #00ff88, #00cc88); }
        .medium-confidence { background: linear-gradient(90deg, #ffcc00, #ffaa00); }
        .low-confidence { background: linear-gradient(90deg, #ff4444, #ff2266); }

        .trend-indicator {
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            margin: 10px 0;
        }

        .up-trend { background: rgba(0, 255, 136, 0.2); color: #00ff88; }
        .down-trend { background: rgba(255, 68, 68, 0.2); color: #ff4444; }
        .neutral-trend { background: rgba(255, 193, 7, 0.2); color: #ffcc00; }

        /* Statistics Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
        }

        .stat-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            margin-top: 5px;
        }

        .volatility-high { color: #ff4444; }
        .volatility-medium { color: #ffcc00; }
        .volatility-low { color: #00ff88; }

        /* Recommendation */
        .recommendation {
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-weight: bold;
            font-size: 1.1em;
            margin: 15px 0;
        }

        .recommendation.strong {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            color: #00ff88;
        }

        .recommendation.moderate {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid #ffcc00;
            color: #ffcc00;
        }

        .recommendation.weak {
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid #ff4444;
            color: #ff4444;
        }

        /* Game History */
        .game-history {
            max-height: 300px;
            overflow-y: auto;
        }

        .history-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: background 0.3s ease;
        }

        .history-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .history-crash {
            font-weight: bold;
        }

        .crash-high { color: #00ff88; }
        .crash-medium { color: #ffcc00; }
        .crash-low { color: #ff4444; }

        /* Prediction Log */
        .prediction-log {
            max-height: 400px;
            overflow-y: auto;
        }

        .log-entry {
            display: grid;
            grid-template-columns: 80px 1fr 1fr 1fr;
            gap: 10px;
            padding: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.9em;
        }

        .log-header {
            font-weight: bold;
            background: rgba(0, 0, 0, 0.3);
            position: sticky;
            top: 0;
        }

        /* Controls */
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }

        .btn {
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-connect {
            background: linear-gradient(45deg, #00ff88, #00ccff);
            color: #000;
        }

        .btn-disconnect {
            background: linear-gradient(45deg, #ff4444, #ff2266);
            color: white;
        }

        .btn-clear {
            background: linear-gradient(45deg, #ffcc00, #ffaa00);
            color: #000;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        /* Footer */
        .footer {
            text-align: center;
            margin-top: 30px;
            opacity: 0.7;
            font-size: 0.9em;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }
    </style>
</head>
<body>


    <iframe src="//streamcrichd.com/update/sonyten1.php" width="100%" height="500px" marginheight="0" marginwidth="0" scrolling="no" frameborder="0" allowfullscreen  allow="encrypted-media"></iframe>
    
    <div class="container">
        <div class="header">
            <h1>üéØ 1xBet Crash Game Predictor</h1>
            <p>Real-time crash point predictions using advanced pattern recognition</p>
        </div>

        <div class="warning">
            ‚ö†Ô∏è <strong>Disclaimer:</strong> This is for educational purposes only. Crash games are based on random number generation. 
            Predictions are not guaranteed. Always gamble responsibly.
        </div>

        <div class="main-content">
            <!-- Left Panel - Predictions -->
            <div class="panel">
                <div class="panel-title">üìä Live Predictions</div>
                
                <div class="connection-status" id="connectionStatus">
                    Status: Disconnected
                </div>

                <div class="prediction-main">
                    <h3>Next Crash Prediction</h3>
                    <div class="prediction-value" id="nextPrediction">--</div>
                    
                    <div class="confidence-meter">
                        <div class="confidence-label" id="confidenceText">Confidence: 0%</div>
                        <div class="confidence-bar">
                            <div class="confidence-fill" id="confidenceBar" style="width: 0%"></div>
                        </div>
                    </div>

                    <div class="trend-indicator neutral-trend" id="trendIndicator">
                        Trend: ANALYZING
                    </div>
                </div>

                <div class="stats-grid">
                    <div class="stat-item">
                        <div>Volatility</div>
                        <div class="stat-value" id="volatility">0%</div>
                    </div>
                    <div class="stat-item">
                        <div>Pattern Strength</div>
                        <div class="stat-value" id="patternStrength">0%</div>
                    </div>
                </div>

                <div class="recommendation weak" id="recommendation">
                    Waiting for game data...
                </div>

                <div class="controls">
                    <button class="btn btn-connect" onclick="connector.connect()">üü¢ Connect</button>
                    <button class="btn btn-disconnect" onclick="connector.disconnect()">üî¥ Disconnect</button>
                    <button class="btn btn-clear" onclick="clearLog()">üóëÔ∏è Clear Log</button>
                </div>
            </div>

            <!-- Right Panel - History & Log -->
            <div class="panel">
                <div class="panel-title">üìà Game History</div>
                <div class="game-history" id="gameHistory">
                    <div class="history-item log-header">
                        <span>Time</span>
                        <span>Crash Point</span>
                        <span>Status</span>
                    </div>
                </div>
            </div>

            <div class="panel" style="grid-column: 1 / -1;">
                <div class="panel-title">üìã Prediction Log</div>
                <div class="prediction-log" id="predictionLog">
                    <div class="log-entry log-header">
                        <span>Time</span>
                        <span>Actual</span>
                        <span>Predicted</span>
                        <span>Confidence</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="footer">
            <p>üî¨ Advanced Prediction Algorithm v2.0 | Data Source: 1xBet Crash Game</p>
            <p>‚ö†Ô∏è Use at your own risk | Not financial advice</p>
        </div>
    </div>

    <script>
        // Enhanced Prediction Algorithm
        class CrashPredictor {
            constructor() {
                this.gameHistory = [];
                this.patterns = [];
                this.confidence = 0;
                this.lastPrediction = null;
            }

            analyzeGameData(currentValue) {
                // Add to game history
                this.gameHistory.push(currentValue);
                
                // Keep only last 20 games for analysis
                if (this.gameHistory.length > 20) {
                    this.gameHistory = this.gameHistory.slice(-20);
                }
                
                return this.calculatePrediction();
            }

            calculatePrediction() {
                if (this.gameHistory.length < 5) {
                    return { value: 0, confidence: 0, trend: 'neutral' };
                }

                const lastValue = this.gameHistory[this.gameHistory.length - 1];
                const average = this.gameHistory.reduce((a, b) => a + b, 0) / this.gameHistory.length;
                
                // Advanced pattern recognition
                const trends = this.analyzeTrends();
                const volatility = this.calculateVolatility();
                const patternStrength = this.detectPatterns();

                // Multi-factor prediction algorithm
                let predictedValue = this.combinedPrediction(lastValue, average, trends, volatility);
                let confidence = this.calculateConfidence(patternStrength, volatility);

                return {
                    value: predictedValue,
                    confidence: Math.round(confidence),
                    trend: trends.overall,
                    volatility: volatility,
                    pattern: patternStrength
                };
            }

            analyzeTrends() {
                const recent = this.gameHistory.slice(-5);
                const medium = this.gameHistory.slice(-10);
                const long = this.gameHistory;
                
                const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;
                const mediumAvg = medium.reduce((a, b) => a + b, 0) / medium.length;
                const longAvg = long.reduce((a, b) => a + b, 0) / long.length;

                return {
                    shortTerm: recentAvg > mediumAvg ? 'up' : 'down',
                    mediumTerm: mediumAvg > longAvg ? 'up' : 'down',
                    overall: recentAvg > longAvg ? 'up' : 'down'
                };
            }

            calculateVolatility() {
                if (this.gameHistory.length < 2) return 0;
                
                const changes = [];
                for (let i = 1; i < this.gameHistory.length; i++) {
                    changes.push(Math.abs(this.gameHistory[i] - this.gameHistory[i-1]));
                }
                
                const avgChange = changes.reduce((a, b) => a + b, 0) / changes.length;
                const maxChange = Math.max(...this.gameHistory) - Math.min(...this.gameHistory);
                
                return (avgChange / maxChange) * 100;
            }

            detectPatterns() {
                // Pattern detection algorithms
                const repeatingPattern = this.checkRepeatingPattern();
                const alternatingPattern = this.checkAlternatingPattern();
                const spikePattern = this.checkSpikePattern();

                return Math.max(repeatingPattern, alternatingPattern, spikePattern);
            }

            checkRepeatingPattern() {
                if (this.gameHistory.length < 4) return 0;
                
                const lastFour = this.gameHistory.slice(-4);
                const unique = new Set(lastFour.map(v => Math.round(v * 10)/10));
                
                return unique.size <= 2 ? 80 : 0;
            }

            checkAlternatingPattern() {
                if (this.gameHistory.length < 5) return 0;
                
                let alternations = 0;
                for (let i = 1; i < this.gameHistory.length - 1; i++) {
                    const prev = this.gameHistory[i-1];
                    const curr = this.gameHistory[i];
                    const next = this.gameHistory[i+1];
                    
                    if ((curr > prev && curr > next) || (curr < prev && curr < next)) {
                        alternations++;
                    }
                }
                
                const alternationRate = alternations / (this.gameHistory.length - 2);
                return alternationRate > 0.6 ? 70 : 0;
            }

            checkSpikePattern() {
                if (this.gameHistory.length < 3) return 0;
                
                const recent = this.gameHistory.slice(-3);
                const changes = [
                    Math.abs(recent[1] - recent[0]),
                    Math.abs(recent[2] - recent[1])
                ];
                
                const avgChange = changes.reduce((a, b) => a + b, 0) / changes.length;
                return avgChange > 2.0 ? 60 : 0;
            }

            combinedPrediction(lastValue, average, trends, volatility) {
                let basePrediction = lastValue;
                
                // Trend influence (40%)
                if (trends.overall === 'up') {
                    basePrediction *= (1 + (volatility / 200));
                } else {
                    basePrediction *= (1 - (volatility / 200));
                }
                
                // Mean reversion influence (30%)
                basePrediction = (basePrediction * 0.7) + (average * 0.3);
                
                // Random factor for unpredictability (10%)
                const randomFactor = 0.9 + (Math.random() * 0.2);
                basePrediction *= randomFactor;
                
                return Math.max(1.01, Math.min(10.0, basePrediction));
            }

            calculateConfidence(patternStrength, volatility) {
                let confidence = 50;
                confidence += (patternStrength / 100) * 30;
                confidence += ((100 - volatility) / 100) * 20;
                
                const dataFactor = Math.min(100, (this.gameHistory.length / 20) * 100);
                confidence = (confidence + dataFactor) / 2;
                
                return Math.min(95, Math.max(10, confidence));
            }
        }

        // WebSocket Connection Handler
        class CrashDataConnector {
            constructor() {
                this.ws = null;
                this.isConnected = false;
                this.gameData = [];
                this.predictor = new CrashPredictor();
                this.currentGame = null;
            }

            connect() {
                try {
                    this.updateConnectionStatus('Connecting...', 'connecting');
                    
                    const wsUrl = 'wss://1xbet.lk/games-frame/sockets/crash?ref=1&gr=911&whence=55&fcountry=208&appGuid=games-web-app-default-web-v3&lng=en&v=1.5';
                    
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => {
                        console.log('‚úÖ WebSocket connected to 1xBet Crash');
                        this.isConnected = true;
                        this.updateConnectionStatus('Connected', 'connected');
                    };
                    
                    this.ws.onmessage = (event) => {
                        this.handleMessage(event.data);
                    };
                    
                    this.ws.onclose = () => {
                        console.log('‚ùå WebSocket disconnected');
                        this.isConnected = false;
                        this.updateConnectionStatus('Disconnected', 'disconnected');
                        setTimeout(() => {
                            if (!this.isConnected) {
                                this.connect();
                            }
                        }, 5000);
                    };
                    
                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.updateConnectionStatus('Connection Error', 'disconnected');
                    };
                    
                } catch (error) {
                    console.error('Connection failed:', error);
                    this.updateConnectionStatus('Connection Failed', 'disconnected');
                }
            }

            handleMessage(data) {
                try {
                    const parsedData = JSON.parse(data);
                    console.log('üìä Received data:', parsedData);
                    
                    const crashValue = this.extractCrashValue(parsedData);
                    
                    if (crashValue && crashValue > 1.0) {
                        this.processGameData(crashValue);
                    } else {
                        // Simulate demo data if no real data found
                        this.processDemoData();
                    }
                    
                } catch (error) {
                    console.log('Raw message:', data);
                    const crashValue = this.extractFromRawData(data);
                    if (crashValue) {
                        this.processGameData(crashValue);
                    } else {
                        this.processDemoData();
                    }
                }
            }

            extractCrashValue(data) {
                if (data.crashPoint || data.crash_point || data.point) {
                    return data.crashPoint || data.crash_point || data.point;
                }
                
                if (data.value !== undefined) {
                    return data.value;
                }
                
                if (data.data && data.data.crashPoint) {
                    return data.data.crashPoint;
                }
                
                return this.findCrashValueInObject(data);
            }

            findCrashValueInObject(obj, depth = 0) {
                if (depth > 3) return null;
                
                for (let key in obj) {
                    if (key.toLowerCase().includes('crash') || key.toLowerCase().includes('point')) {
                        const value = obj[key];
                        if (typeof value === 'number' && value > 1.0) {
                            return value;
                        }
                    }
                    
                    if (typeof obj[key] === 'object' && obj[key] !== null) {
                        const result = this.findCrashValueInObject(obj[key], depth + 1);
                        if (result) return result;
                    }
                }
                
                return null;
            }

            extractFromRawData(rawData) {
                const regex = /[0-9]+\.[0-9]+/g;
                const matches = rawData.match(regex);
                
                if (matches) {
                    for (let match of matches) {
                        const value = parseFloat(match);
                        if (value > 1.0 && value < 100.0) {
                            return value;
                        }
                    }
                }
                
                return null;
            }

            processGameData(crashValue) {
                this.gameData.push({
                    value: crashValue,
                    timestamp: Date.now()
                });
                
                if (this.gameData.length > 50) {
                    this.gameData = this.gameData.slice(-50);
                }
                
                this.updatePredictor(crashValue);
                this.updateGameHistory(crashValue);
            }

            processDemoData() {
                // Demo data for testing
                const demoValue = 1.5 + Math.random() * 8.5;
                this.processGameData(demoValue);
            }

            updatePredictor(currentValue) {
                const prediction = this.predictor.analyzeGameData(currentValue);
                this.updatePredictionDisplay(prediction, currentValue);
                
                console.log(`üéØ Crash: ${currentValue.toFixed(2)}x | Prediction: ${prediction.value.toFixed(2)}x | Confidence: ${prediction.confidence}%`);
            }

            updatePredictionDisplay(prediction, currentValue) {
                // Update main prediction display
                document.getElementById('nextPrediction').textContent = prediction.value.toFixed(2) + 'x';
                document.getElementById('confidenceText').textContent = `Confidence: ${prediction.confidence}%`;
                
                // Update confidence bar
                const confidenceBar = document.getElementById('confidenceBar');
                confidenceBar.style.width = prediction.confidence + '%';
                
                if (prediction.confidence > 70) {
                    confidenceBar.className = 'confidence-fill high-confidence';
                } else if (prediction.confidence > 40) {
                    confidenceBar.className = 'confidence-fill medium-confidence';
                } else {
                    confidenceBar.className = 'confidence-fill low-confidence';
                }
                
                // Update trend indicator
                const trendIndicator = document.getElementById('trendIndicator');
                trendIndicator.className = `trend-indicator ${prediction.trend}-trend`;
                trendIndicator.textContent = `Trend: ${prediction.trend.toUpperCase()}`;
                
                // Update statistics
                document.getElementById('volatility').textContent = prediction.volatility.toFixed(1) + '%';
                document.getElementById('patternStrength').textContent = prediction.pattern.toFixed(0) + '%';
                
                // Update volatility color
                const volatilityElement = document.getElementById('volatility');
                volatilityElement.className = 'stat-value ' + 
                    (prediction.volatility > 60 ? 'volatility-high' : 
                     prediction.volatility > 30 ? 'volatility-medium' : 'volatility-low');
                
                // Update recommendation
                const recommendation = document.getElementById('recommendation');
                if (prediction.confidence > 75) {
                    recommendation.textContent = 'üéØ Strong signal - Consider action';
                    recommendation.className = 'recommendation strong';
                } else if (prediction.confidence > 50) {
                    recommendation.textContent = '‚ö†Ô∏è Moderate signal - Monitor closely';
                    recommendation.className = 'recommendation moderate';
                } else {
                    recommendation.textContent = 'üîª Weak signal - Wait for better opportunity';
                    recommendation.className = 'recommendation weak';
                }
                
                // Add to prediction log
                this.addPredictionLog(currentValue, prediction);
            }

            updateGameHistory(crashValue) {
                const historyContainer = document.getElementById('gameHistory');
                const time = new Date().toLocaleTimeString();
                
                const historyItem = document.createElement('div');
                historyItem.className = 'history-item';
                
                let crashClass = 'crash-medium';
                if (crashValue > 5.0) crashClass = 'crash-high';
                if (crashValue < 2.0) crashClass = 'crash-low';
                
                historyItem.innerHTML = `
                    <span>${time}</span>
                    <span class="history-crash ${crashClass}">${crashValue.toFixed(2)}x</span>
                    <span>${crashValue > 2.0 ? 'üü¢ Good' : 'üî¥ Low'}</span>
                `;
                
                // Add after header
                const header = historyContainer.querySelector('.log-header');
                historyContainer.insertBefore(historyItem, header.nextSibling);
                
                // Keep only last 15 entries
                const entries = historyContainer.querySelectorAll('.history-item');
                if (entries.length > 16) { // 15 + header
                    historyContainer.removeChild(entries[entries.length - 1]);
                }
            }

            addPredictionLog(currentValue, prediction) {
                const logContainer = document.getElementById('predictionLog');
                const time = new Date().toLocaleTimeString();
                
                const logEntry = document.createElement('div');
                logEntry.className = 'log-entry';
                
                logEntry.innerHTML = `
                    <span>${time}</span>
                    <span>${currentValue.toFixed(2)}x</span>
                    <span>${prediction.value.toFixed(2)}x</span>
                    <span>${prediction.confidence}%</span>
                `;
                
                // Add after header
                const header = logContainer.querySelector('.log-header');
                logContainer.insertBefore(logEntry, header.nextSibling);
                
                // Keep only last 20 entries
                const entries = logContainer.querySelectorAll('.log-entry');
                if (entries.length > 21) { // 20 + header
                    logContainer.removeChild(entries[entries.length - 1]);
                }
            }

            updateConnectionStatus(status, type) {
                const statusElement = document.getElementById('connectionStatus');
                statusElement.textContent = `Status: ${status}`;
                statusElement.className = `connection-status status-${type}`;
            }

            disconnect() {
                if (this.ws) {
                    this.ws.close();
                }
                this.isConnected = false;
                this.updateConnectionStatus('Disconnected', 'disconnected');
            }
        }

        // Global connector instance
        let connector;

        function initializePredictor() {
            connector = new CrashDataConnector();
            
            // Auto-connect after 2 seconds
            setTimeout(() => {
                connector.connect();
            }, 2000);
        }

        function clearLog() {
            const logContainer = document.getElementById('predictionLog');
            const historyContainer = document.getElementById('gameHistory');
            
            const logEntries = logContainer.querySelectorAll('.log-entry:not(.log-header)');
            const historyEntries = historyContainer.querySelectorAll('.history-item:not(.log-header)');
            
            logEntries.forEach(entry => entry.remove());
            historyEntries.forEach(entry => entry.remove());
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', initializePredictor);
    </script>
</body>
</html>
